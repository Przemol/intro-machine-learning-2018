[
["svm.html", "9 Support vector machines 9.1 Introduction 9.2 Support vector classifier 9.3 Support Vector Machine 9.4 Example - training a classifier 9.5 Example - regression 9.6 Further reading 9.7 Exercises", " 9 Support vector machines 9.1 Introduction Support vector machines (SVMs) are models of supervised learning, applicable to both classification and regression problems. The SVM is an extension of the support vector classifier (SVC), which is turn is an extension of the maximum margin classifier. 9.1.1 Maximum margin classifier Let’s start by definining a hyperplane. In p-dimensional space a hyperplane is a flat affine subspace of p-1. Figure 9.1 shows three separating hyperplanes and objects of two different classes. A separating hyperplane forms a natural linear decision boundary, classifying new objects according to which side of the line they are located. Figure 9.1: Left: two classes of observations (blue, purple) and three separating hyperplanes. Right: separating hyperplane shown as black line and grid indicates decision rule. Source: http://www-bcf.usc.edu/~gareth/ISL/ If the classes of observations can be separated by a hyperplane, then there will in fact be an infinite number of hyperplanes. So which of the possible hyperplanes do we choose to be our decision boundary? The maximal margin hyperplane is the separating hyperplane that is farthest from the training observations. The perpendicular distance from a given hyperplane to the nearest training observation is known as the margin. The maximal margin hyperplane is the separating hyperplane for which the margin is largest. Figure 9.2: Maximal margin hyperplane shown as solid line. Margin is the distance from the solid line to either of the dashed lines. The support vectors are the points on the dashed line. Source: http://www-bcf.usc.edu/~gareth/ISL/ Figure 9.2 shows three training observations that are equidistant from the maximal margin hyperplane and lie on the dashed lines indicating the margin. These are the support vectors. If these points were moved slightly, the maximal margin hyperplane would also move, hence the term support. The maximal margin hyperplane is set by the support vectors alone; it is not influenced by any other observations. The maximal margin hyperplane is a natural decision boundary, but only if a separating hyperplane exists. In practice there may be non separable cases which prevent the use of the maximal margin classifier. Figure 9.3: The two classes cannot be separated by a hyperplane and so the maximal margin classifier cannot be used. Source: http://www-bcf.usc.edu/~gareth/ISL/ 9.2 Support vector classifier Even if a separating hyperplane exists, it may not be the best decision boundary. The maximal margin classifier is extremely sensitive to individual observations, so may overfit the training data. Figure 9.4: Left: two classes of observations and a maximum margin hyperplane (solid line). Right: Hyperplane (solid line) moves after the addition of a new observation (original hyperplane is dashed line). Source: http://www-bcf.usc.edu/~gareth/ISL/ It would be better to choose a classifier base on a hyperplane that: is more robust to individual observations provides better classification of most of the training variables In other words, we might tolerate some misclassifications if the prediction of the remaining observations is more reliable. The support vector classifier does this by allowing some observations to be on the wrong side of the margin or even on the wrong side of the hyperplane. Observations on the wrong side of the hyperplane are misclassifications. Figure 9.5: Left: observations on the wrong side of the margin. Right: observations on the wrong side of the margin and observations on the wrong side of the hyperplane. Source: http://www-bcf.usc.edu/~gareth/ISL/ The support vector classifier has a tuning parameter, C, that determines the number and severity of the violations to the margin. If C = 0, then no violations to the margin will be tolerated, which is equivalent to the maximal margin classifier. As C increases, the classifier becomes more tolerant of violations to the margin, and so the margin widens. The optimal value of C is chosen through cross-validation. C is described as a tuning parameter, because it controls the bias-variance trade-off: a small C results in narrow margins that are rarely violated; the model will have low bias, but high variance. as C increases the margins widen allowing more violations; the bias of the model will increase, but its variance will decrease. The support vectors are the observations that lie directly on the margin, or on the wrong side of the margin for their class. The only observations that affect the classifier are the support vectors. As C increases, the margin widens and the number of support vectors increases. In other words, when C increases more observations are involved in determining the decision boundary of the classifier. Figure 9.6: Margin of a support vector classifier changing with tuning parameter C. Largest value of C was used in the top left panel, and smaller values in the top right, bottom left and bottom right panels. Source: http://www-bcf.usc.edu/~gareth/ISL/ 9.3 Support Vector Machine The support vector classifier performs well if we have linearly separable classes, however this isn’t always the case. Figure 9.7: Two classes of observations with a non-linear boundary between them. The SVM uses the kernel trick to project the data into higher dimensions where a separating linear hyperplane may be found. Figure 9.8: Kernel machine. By Alisneaky - Own work, CC0, https://commons.wikimedia.org/w/index.php?curid=14941564 Figure 9.9: Left: SVM with polynomial kernel of degree 3. Right: SVM with radial kernel. Source: http://www-bcf.usc.edu/~gareth/ISL/ 9.4 Example - training a classifier Training of an SVM will be demonstrated on a 2-dimensional simulated data set, with a non-linear decision boundary. 9.4.1 Setup environment Load required libraries library(caret) ## Loading required package: lattice ## Loading required package: ggplot2 library(RColorBrewer) library(ggplot2) library(doMC) ## Loading required package: foreach ## Loading required package: iterators ## Loading required package: parallel library(pROC) ## Type &#39;citation(&quot;pROC&quot;)&#39; for a citation. ## ## Attaching package: &#39;pROC&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## cov, smooth, var library(e1071) Initialize parallel processing registerDoMC() getDoParWorkers() ## [1] 2 9.4.2 Partition data Load data moons &lt;- read.csv(&quot;data/sim_data_svm/moons.csv&quot;, header=F) str(moons) ## &#39;data.frame&#39;: 400 obs. of 3 variables: ## $ V1: num -0.496 1.827 1.322 -1.138 -0.21 ... ## $ V2: num 0.985 -0.501 -0.397 0.192 -0.145 ... ## $ V3: Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 2 2 1 2 1 1 2 1 2 ... V1 and V2 are the predictors; V3 is the class. Partition data into training and test set set.seed(42) trainIndex &lt;- createDataPartition(y=moons$V3, times=1, p=0.7, list=F) moonsTrain &lt;- moons[trainIndex,] moonsTest &lt;- moons[-trainIndex,] summary(moonsTrain$V3) ## A B ## 140 140 summary(moonsTest$V3) ## A B ## 60 60 9.4.3 Visualize training data point_shapes &lt;- c(15,17) bp &lt;- brewer.pal(3,&quot;Dark2&quot;) point_colours &lt;- ifelse(moonsTrain$V3==&quot;A&quot;, bp[1], bp[2]) point_shapes &lt;- ifelse(moonsTrain$V3==&quot;A&quot;, 15, 17) point_size = 2 ggplot(moonsTrain, aes(V1,V2)) + geom_point(col=point_colours, shape=point_shapes, size=point_size) + theme_bw() + theme(plot.title = element_text(size=25, face=&quot;bold&quot;), axis.text=element_text(size=15), axis.title=element_text(size=20,face=&quot;bold&quot;)) Figure 9.10: Scatterplot of the training data 9.4.4 Define a custom model Caret has over two hundred built in models, including several support vector machines: https://topepo.github.io/caret/available-models.html However, despite this wide range of options, you may occasionally need to define your own model. Caret does not currently have a radial SVM implemented using the e1071 library, so we will define one here. svmRadialE1071 &lt;- list( label = &quot;Support Vector Machines with Radial Kernel - e1071&quot;, library = &quot;e1071&quot;, type = c(&quot;Regression&quot;, &quot;Classification&quot;), parameters = data.frame(parameter=&quot;cost&quot;, class=&quot;numeric&quot;, label=&quot;Cost&quot;), grid = function (x, y, len = NULL, search = &quot;grid&quot;) { if (search == &quot;grid&quot;) { out &lt;- expand.grid(cost = 2^((1:len) - 3)) } else { out &lt;- data.frame(cost = 2^runif(len, min = -5, max = 10)) } out }, loop=NULL, fit=function (x, y, wts, param, lev, last, classProbs, ...) { if (any(names(list(...)) == &quot;probability&quot;) | is.numeric(y)) { out &lt;- e1071::svm(x = as.matrix(x), y = y, kernel = &quot;radial&quot;, cost = param$cost, ...) } else { out &lt;- e1071::svm(x = as.matrix(x), y = y, kernel = &quot;radial&quot;, cost = param$cost, probability = classProbs, ...) } out }, predict = function (modelFit, newdata, submodels = NULL) { predict(modelFit, newdata) }, prob = function (modelFit, newdata, submodels = NULL) { out &lt;- predict(modelFit, newdata, probability = TRUE) attr(out, &quot;probabilities&quot;) }, predictors = function (x, ...) { out &lt;- if (!is.null(x$terms)) predictors.terms(x$terms) else x$xNames if (is.null(out)) out &lt;- names(attr(x, &quot;scaling&quot;)$x.scale$`scaled:center`) if (is.null(out)) out &lt;- NA out }, tags = c(&quot;Kernel Methods&quot;, &quot;Support Vector Machines&quot;, &quot;Regression&quot;, &quot;Classifier&quot;, &quot;Robust Methods&quot;), levels = function(x) x$levels, sort = function(x) { x[order(x$cost), ] } ) Note that the radial SVM model we have defined has only one tuning parameter, cost (C). If we do not define the kernel parameter gamma, e1071 will automatically calculate it as 1/(data dimension); i.e. if we have 58 predictors, gamma will be 1/58 = 0.01724. 9.4.5 Model cross-validation and tuning Set seeds for reproducibility. We will be trying 9 values of the tuning parameter with 10 repeats of 10 fold cross-validation, so we need the following list of seeds. set.seed(42) seeds &lt;- vector(mode = &quot;list&quot;, length = 26) for(i in 1:25) seeds[[i]] &lt;- sample.int(1000, 9) seeds[[26]] &lt;- sample.int(1000,1) We will pass the twoClassSummary function into model training through trainControl. Additionally we would like the model to predict class probabilities so that we can calculate the ROC curve, so we use the classProbs option. cvCtrl &lt;- trainControl(method = &quot;repeatedcv&quot;, repeats = 5, number = 5, summaryFunction = twoClassSummary, classProbs = TRUE, seeds=seeds) We set the method of the train function to svmRadial to specify a radial kernel SVM. In this implementation we only have to tune one parameter, cost. The default grid of cost parameters start at 0.25 and double at each iteration. Choosing tuneLength = 9 will give us cost parameters of 0.25, 0.5, 1, 2, 4, 8, 16, 32 and 64. svmTune &lt;- train(x = moonsTrain[,c(1:2)], y = moonsTrain[,3], method = svmRadialE1071, tuneLength = 9, preProc = c(&quot;center&quot;, &quot;scale&quot;), metric = &quot;ROC&quot;, trControl = cvCtrl) svmTune ## Support Vector Machines with Radial Kernel - e1071 ## ## 280 samples ## 2 predictor ## 2 classes: &#39;A&#39;, &#39;B&#39; ## ## Pre-processing: centered (2), scaled (2) ## Resampling: Cross-Validated (5 fold, repeated 5 times) ## Summary of sample sizes: 224, 224, 224, 224, 224, 224, ... ## Resampling results across tuning parameters: ## ## cost ROC Sens Spec ## 0.25 0.9337245 0.8485714 0.8900000 ## 0.50 0.9437245 0.8571429 0.8942857 ## 1.00 0.9517857 0.8542857 0.8971429 ## 2.00 0.9584184 0.8685714 0.9014286 ## 4.00 0.9611224 0.8785714 0.9014286 ## 8.00 0.9633163 0.8842857 0.8985714 ## 16.00 0.9633673 0.8900000 0.8957143 ## 32.00 0.9629592 0.8914286 0.8914286 ## 64.00 0.9609184 0.8771429 0.8871429 ## ## ROC was used to select the optimal model using the largest value. ## The final value used for the model was cost = 16. svmTune$finalModel ## ## Call: ## svm.default(x = as.matrix(x), y = y, kernel = &quot;radial&quot;, cost = param$cost, ## probability = classProbs) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: radial ## cost: 16 ## gamma: 0.5 ## ## Number of Support Vectors: 79 9.4.6 Prediction performance measures SVM accuracy profile plot(svmTune, metric = &quot;ROC&quot;, scales = list(x = list(log =2))) Figure 9.11: SVM accuracy profile for moons data set. Predictions on test set. svmPred &lt;- predict(svmTune, moonsTest[,c(1:2)]) confusionMatrix(svmPred, moonsTest[,3]) ## Confusion Matrix and Statistics ## ## Reference ## Prediction A B ## A 56 6 ## B 4 54 ## ## Accuracy : 0.9167 ## 95% CI : (0.8521, 0.9593) ## No Information Rate : 0.5 ## P-Value [Acc &gt; NIR] : &lt;2e-16 ## ## Kappa : 0.8333 ## Mcnemar&#39;s Test P-Value : 0.7518 ## ## Sensitivity : 0.9333 ## Specificity : 0.9000 ## Pos Pred Value : 0.9032 ## Neg Pred Value : 0.9310 ## Prevalence : 0.5000 ## Detection Rate : 0.4667 ## Detection Prevalence : 0.5167 ## Balanced Accuracy : 0.9167 ## ## &#39;Positive&#39; Class : A ## Get predicted class probabilities so we can build ROC curve. svmProbs &lt;- predict(svmTune, moonsTest[,c(1:2)], type=&quot;prob&quot;) head(svmProbs) ## A B ## 2 0.006794294 0.99320571 ## 5 0.056411649 0.94358835 ## 6 0.966313899 0.03368610 ## 7 0.996845020 0.00315498 ## 8 0.023448085 0.97655192 ## 9 0.939438609 0.06056139 Build a ROC curve. svmROC &lt;- roc(moonsTest[,3], svmProbs[,&quot;A&quot;]) auc(svmROC) ## Area under the curve: 0.96 Plot ROC curve, including the threshold with the highest sum sensitivity + specificity. plot(svmROC, type = &quot;S&quot;, print.thres = 0.5, print.thres.col = &quot;blue&quot;, print.thres.pch = 19, print.thres.cex=1.5) Figure 9.12: SVM accuracy profile. Sensitivity (true positive rate) TPR = TP/P = TP/(TP+FN) Specificity (true negative rate) SPC = TN/N = TN/(TN+FP) Calculate area under ROC curve. auc(svmROC) ## Area under the curve: 0.96 9.4.7 Plot decision boundary Create a grid so we can predict across the full range of our variables V1 and V2. gridSize &lt;- 150 v1limits &lt;- c(min(moons$V1),max(moons$V1)) tmpV1 &lt;- seq(v1limits[1],v1limits[2],len=gridSize) v2limits &lt;- c(min(moons$V2), max(moons$V2)) tmpV2 &lt;- seq(v2limits[1],v2limits[2],len=gridSize) xgrid &lt;- expand.grid(tmpV1,tmpV2) names(xgrid) &lt;- names(moons)[1:2] Predict values of all elements of grid. V3 &lt;- as.numeric(predict(svmTune, xgrid)) xgrid &lt;- cbind(xgrid, V3) Plot point_shapes &lt;- c(15,17) point_colours &lt;- brewer.pal(3,&quot;Dark2&quot;) point_size = 2 trainClassNumeric &lt;- ifelse(moonsTrain$V3==&quot;A&quot;, 1, 2) testClassNumeric &lt;- ifelse(moonsTest$V3==&quot;A&quot;, 1, 2) ggplot(xgrid, aes(V1,V2)) + geom_point(col=point_colours[V3], shape=16, size=0.3) + geom_point(data=moonsTrain, aes(V1,V2), col=point_colours[trainClassNumeric], shape=point_shapes[trainClassNumeric], size=point_size) + geom_contour(data=xgrid, aes(x=V1, y=V2, z=V3), breaks=1.5, col=&quot;grey30&quot;) + ggtitle(&quot;train&quot;) + theme_bw() + theme(plot.title = element_text(size=25, face=&quot;bold&quot;), axis.text=element_text(size=15), axis.title=element_text(size=20,face=&quot;bold&quot;)) ggplot(xgrid, aes(V1,V2)) + geom_point(col=point_colours[V3], shape=16, size=0.3) + geom_point(data=moonsTest, aes(V1,V2), col=point_colours[testClassNumeric], shape=point_shapes[testClassNumeric], size=point_size) + geom_contour(data=xgrid, aes(x=V1, y=V2, z=V3), breaks=1.5, col=&quot;grey30&quot;) + ggtitle(&quot;test&quot;) + theme_bw() + theme(plot.title = element_text(size=25, face=&quot;bold&quot;), axis.text=element_text(size=15), axis.title=element_text(size=20,face=&quot;bold&quot;)) Figure 9.13: Decision boundary created by radial kernel SVM. 9.5 Example - regression This example serves to demonstrate the use of SVMs in regression, but perhaps more importantly, it highlights the power and flexibility of the caret package. Earlier we used k-NN for a regression analysis of the BloodBrain dataset (see section 8.409). We will repeat the regression analysis, but this time we will fit a radial kernel SVM. Remarkably, a re-run of this analysis using a completely different type of model, requires changes to only two lines of code. The pre-processing steps and generation of seeds are identical, therefore if the data were still in memory, we could skip this next block of code: data(BloodBrain) set.seed(42) trainIndex &lt;- createDataPartition(y=logBBB, times=1, p=0.8, list=F) descrTrain &lt;- bbbDescr[trainIndex,] concRatioTrain &lt;- logBBB[trainIndex] descrTest &lt;- bbbDescr[-trainIndex,] concRatioTest &lt;- logBBB[-trainIndex] set.seed(42) seeds &lt;- vector(mode = &quot;list&quot;, length = 26) for(i in 1:25) seeds[[i]] &lt;- sample.int(1000, 50) seeds[[26]] &lt;- sample.int(1000,1) In the arguments to the train function we change method from knn to svmRadialE1071. The tunegrid parameter is replaced with tuneLength = 9. Now we are ready to fit an SVM model. svmTune2 &lt;- train(descrTrain, concRatioTrain, method=svmRadialE1071, preProcess = c(&quot;center&quot;, &quot;scale&quot;, &quot;corr&quot;, &quot;nzv&quot;), tuneLength = 9, trControl = trainControl(method=&quot;repeatedcv&quot;, number = 5, repeats = 5, seeds=seeds, preProcOptions=list(cutoff=0.75) ) ) ## Warning in nominalTrainWorkflow(x = x, y = y, wts = weights, info = ## trainInfo, : There were missing values in resampled performance measures. svmTune2 ## Support Vector Machines with Radial Kernel - e1071 ## ## 168 samples ## 134 predictors ## ## Pre-processing: centered (61), scaled (61), remove (73) ## Resampling: Cross-Validated (5 fold, repeated 5 times) ## Summary of sample sizes: 134, 136, 134, 133, 135, 134, ... ## Resampling results across tuning parameters: ## ## cost RMSE Rsquared MAE ## 0.25 0.5897361 0.5057243 0.4371828 ## 0.50 0.5549909 0.5278095 0.4104311 ## 1.00 0.5403895 0.5232633 0.4070214 ## 2.00 0.5342050 0.5227053 0.4041875 ## 4.00 0.5321020 0.5250414 0.4014602 ## 8.00 0.5296600 0.5290777 0.4022885 ## 16.00 0.5291135 0.5299735 0.4021494 ## 32.00 0.5291135 0.5299735 0.4021494 ## 64.00 0.5291135 0.5299735 0.4021494 ## ## RMSE was used to select the optimal model using the smallest value. ## The final value used for the model was cost = 16. plot(svmTune2) Figure 9.14: Root Mean Squared Error as a function of cost. Use model to predict outcomes, after first pre-processing the test set. test_pred &lt;- predict(svmTune2, descrTest) Prediction performance can be visualized in a scatterplot. qplot(concRatioTest, test_pred) + xlab(&quot;observed&quot;) + ylab(&quot;predicted&quot;) + theme_bw() Figure 9.15: Concordance between observed concentration ratios and those predicted by radial kernel SVM. We can also measure correlation between observed and predicted values. cor(concRatioTest, test_pred) ## [1] 0.8078836 9.6 Further reading An Introduction to Statistical Learning 9.7 Exercises 9.7.1 Exercise 1 In this exercise we will return to the cell segmentation data set that we attempted to classify using k-nn in section 8.131 of the nearest neighbours chapter. data(segmentationData) The aim of the exercise is to build a binary classifier to predict the quality of segmentation (poorly segmented or well segmented) based on the various morphological features. Do not worry about feature selection, but you may want to pre-process the data. Use a radial SVM model and tune over the cost function C. Produce a ROC curve to show the performance of the classifier on the test set. Solutions to exercises can be found in appendix G "]
]
